.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WIRESHARK-FILTER 4"
.TH WIRESHARK-FILTER 4 2019-02-28 3.0.0 "The Wireshark Network Analyzer"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
wireshark\-filter \- Wireshark filter syntax and reference
.SH SYNOPSIS
.IX Header "SYNOPSIS"
\&\fBwireshark\fR [other options]
[\ \fB\-R\fR\ "filter\ expression"\ ]
.PP
\&\fBtshark\fR [other options]
[\ \fB\-R\fR\ "filter\ expression"\ ]
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fBWireshark\fR and \fBTShark\fR share a powerful filter engine that helps remove
the noise from a packet trace and lets you see only the packets that interest
you.  If a packet meets the requirements expressed in your filter, then it
is displayed in the list of packets.  Display filters let you compare the
fields within a protocol against a specific value, compare fields against
fields, and check the existence of specified fields or protocols.
.PP
Filters are also used by other features such as statistics generation and
packet list colorization (the latter is only available to \fBWireshark\fR). This
manual page describes their syntax. A comprehensive reference of filter fields
can be found within Wireshark and in the display filter reference at
<https://www.wireshark.org/docs/dfref/>.
.SH "FILTER SYNTAX"
.IX Header "FILTER SYNTAX"
.SS "Check whether a field or protocol exists"
.IX Subsection "Check whether a field or protocol exists"
The simplest filter allows you to check for the existence of a protocol or
field.  If you want to see all packets which contain the IP protocol, the
filter would be "ip" (without the quotation marks). To see all packets
that contain a Token-Ring RIF field, use "tr.rif".
.PP
Think of a protocol or field in a filter as implicitly having the "exists"
operator.
.SS "Comparison operators"
.IX Subsection "Comparison operators"
Fields can also be compared against values.  The comparison operators
can be expressed either through English-like abbreviations or through
C\-like symbols:
.PP
.Vb 6
\&    eq, ==    Equal
\&    ne, !=    Not Equal
\&    gt, >     Greater Than
\&    lt, <     Less Than
\&    ge, >=    Greater than or Equal to
\&    le, <=    Less than or Equal to
.Ve
.SS "Search and match operators"
.IX Subsection "Search and match operators"
Additional operators exist expressed only in English, not C\-like syntax:
.PP
.Vb 3
\&    contains     Does the protocol, field or slice contain a value
\&    matches, ~   Does the protocol or text string match the given
\&                 case\-insensitive Perl\-compatible regular expression
.Ve
.PP
The "contains" operator allows a filter to search for a sequence of
characters, expressed as a string (quoted or unquoted), or bytes,
expressed as a byte array, or for a single character, expressed as a
C\-style character constant.  For example, to search for a given HTTP
URL in a capture, the following filter can be used:
.PP
.Vb 1
\&    http contains "https://www.wireshark.org"
.Ve
.PP
The "contains" operator cannot be used on atomic fields,
such as numbers or IP addresses.
.PP
The "matches"  or "~" operator allows a filter to apply to a specified
Perl-compatible regular expression (PCRE).  The "matches" operator is only
implemented for protocols and for protocol fields with a text string
representation. Matches are case-insensitive by default.  For example,
to search for a given WAP WSP User-Agent, you can write:
.PP
.Vb 1
\&    wsp.user_agent matches "cldc"
.Ve
.PP
This would match "cldc", "CLDC", "cLdC" or any other combination of upper
and lower case letters.
.PP
You can force case sensitivity using
.PP
.Vb 1
\&    wsp.user_agent matches "(?\-i)cldc"
.Ve
.PP
This is an example of PCRE's \fB(?\fRoption\fB)\fR construct. \fB(?\-i)\fR performs a
case-sensitive pattern match but other options can be specified as well. More
information can be found in the \fBpcrepattern\fR\|(3) man page at
<http://perldoc.perl.org/perlre.html>).
.SS Functions
.IX Subsection "Functions"
The filter language has the following functions:
.PP
.Vb 5
\&    upper(string\-field) \- converts a string field to uppercase
\&    lower(string\-field) \- converts a string field to lowercase
\&    len(field)          \- returns the byte length of a string or bytes field
\&    count(field)        \- returns the number of field occurrences in a frame
\&    string(field)       \- converts a non\-string field to string
.Ve
.PP
\&\fBupper()\fR and \fBlower()\fR are useful for performing case-insensitive string
comparisons. For example:
.PP
.Vb 2
\&    upper(ncp.nds_stream_name) contains "MACRO"
\&    lower(mount.dump.hostname) == "angel"
.Ve
.PP
\&\fBstring()\fR converts a field value to a string, suitable for use with operators like
"matches" or "contains". Integer fields are converted to their decimal representation.
It can be used with IP/Ethernet addresses (as well as others), but not with string or
byte fields. For example:
.PP
.Vb 1
\&    string(frame.number) matches "[13579]$"
.Ve
.PP
gives you all the odd packets.
.SS "Protocol field types"
.IX Subsection "Protocol field types"
Each protocol field is typed. The types are:
.PP
.Vb 10
\&    ASN.1 object identifier
\&    Boolean
\&    Character string
\&    Compiled Perl\-Compatible Regular Expression (GRegex) object
\&    Date and time
\&    Ethernet or other MAC address
\&    EUI64 address
\&    Floating point (double\-precision)
\&    Floating point (single\-precision)
\&    Frame number
\&    Globally Unique Identifier
\&    IPv4 address
\&    IPv6 address
\&    IPX network number
\&    Label
\&    Protocol
\&    Sequence of bytes
\&    Signed integer, 1, 2, 3, 4, or 8 bytes
\&    Time offset
\&    Unsigned integer, 1, 2, 3, 4, or 8 bytes
\&    1\-byte ASCII character
.Ve
.PP
An integer may be expressed in decimal, octal, or hexadecimal notation,
or as a C\-style character constant.  The following six display filters
are equivalent:
.PP
.Vb 6
\&    frame.pkt_len > 10
\&    frame.pkt_len > 012
\&    frame.pkt_len > 0xa
\&    frame.pkt_len > \*(Aq\en\*(Aq
\&    frame.pkt_len > \*(Aq\exa\*(Aq
\&    frame.pkt_len > \*(Aq\e012\*(Aq
.Ve
.PP
Boolean values are either true or false.  In a display filter expression
testing the value of a Boolean field, "true" is expressed as 1 or any
other non-zero value, and "false" is expressed as zero.  For example, a
token-ring packet's source route field is Boolean.  To find any
source-routed packets, a display filter would be:
.PP
.Vb 1
\&    tr.sr == 1
.Ve
.PP
Non source-routed packets can be found with:
.PP
.Vb 1
\&    tr.sr == 0
.Ve
.PP
Ethernet addresses and byte arrays are represented by hex
digits.  The hex digits may be separated by colons, periods, or hyphens:
.PP
.Vb 4
\&    eth.dst eq ff:ff:ff:ff:ff:ff
\&    aim.data == 0.1.0.d
\&    fddi.src == aa\-aa\-aa\-aa\-aa\-aa
\&    echo.data == 7a
.Ve
.PP
IPv4 addresses can be represented in either dotted decimal notation or
by using the hostname:
.PP
.Vb 2
\&    ip.dst eq www.mit.edu
\&    ip.src == 192.168.1.1
.Ve
.PP
IPv4 addresses can be compared with the same logical relations as numbers:
eq, ne, gt, ge, lt, and le.  The IPv4 address is stored in host order,
so you do not have to worry about the endianness of an IPv4 address
when using it in a display filter.
.PP
Classless InterDomain Routing (CIDR) notation can be used to test if an
IPv4 address is in a certain subnet.  For example, this display filter
will find all packets in the 129.111 Class-B network:
.PP
.Vb 1
\&    ip.addr == 129.111.0.0/16
.Ve
.PP
Remember, the number after the slash represents the number of bits used
to represent the network.  CIDR notation can also be used with
hostnames, as in this example of finding IP addresses on the same Class C
network as 'sneezy':
.PP
.Vb 1
\&    ip.addr eq sneezy/24
.Ve
.PP
The CIDR notation can only be used on IP addresses or hostnames, not in
variable names.  So, a display filter like "ip.src/24 == ip.dst/24" is
not valid (yet).
.PP
IPX networks are represented by unsigned 32\-bit integers.  Most likely
you will be using hexadecimal when testing IPX network values:
.PP
.Vb 1
\&    ipx.src.net == 0xc0a82c00
.Ve
.PP
Strings are enclosed in double quotes:
.PP
.Vb 1
\&    http.request.method == "POST"
.Ve
.PP
Inside double quotes, you may use a backslash to embed a double quote
or an arbitrary byte represented in either octal or hexadecimal.
.PP
.Vb 1
\&    browser.comment == "An embedded \e" double\-quote"
.Ve
.PP
Use of hexadecimal to look for "HEAD":
.PP
.Vb 1
\&    http.request.method == "\ex48EAD"
.Ve
.PP
Use of octal to look for "HEAD":
.PP
.Vb 1
\&    http.request.method == "\e110EAD"
.Ve
.PP
This means that you must escape backslashes with backslashes inside
double quotes.
.PP
.Vb 1
\&    smb.path contains "\e\e\e\eSERVER\e\eSHARE"
.Ve
.PP
looks for \e\eSERVER\eSHARE in "smb.path".
.SS "The slice operator"
.IX Subsection "The slice operator"
You can take a slice of a field if the field is a text string or a
byte array.
For example, you can filter on
the vendor portion of an ethernet address (the first three bytes) like
this:
.PP
.Vb 1
\&    eth.src[0:3] == 00:00:83
.Ve
.PP
Another example is:
.PP
.Vb 1
\&    http.content_type[0:4] == "text"
.Ve
.PP
You can use the slice operator on a protocol name, too.
The "frame" protocol can be useful, encompassing all the data captured
by \fBWireshark\fR or \fBTShark\fR.
.PP
.Vb 3
\&    token[0:5] ne 0.0.0.1.1
\&    llc[0] eq aa
\&    frame[100\-199] contains "wireshark"
.Ve
.PP
The following syntax governs slices:
.PP
.Vb 5
\&    [i:j]    i = start_offset, j = length
\&    [i\-j]    i = start_offset, j = end_offset, inclusive.
\&    [i]      i = start_offset, length = 1
\&    [:j]     start_offset = 0, length = j
\&    [i:]     start_offset = i, end_offset = end_of_field
.Ve
.PP
Offsets can be negative, in which case they indicate the
offset from the \fBend\fR of the field.  The last byte of the field is at offset
\&\-1, the last but one byte is at offset \-2, and so on.
Here's how to check the last four bytes of a frame:
.PP
.Vb 1
\&    frame[\-4:4] == 0.1.2.3
.Ve
.PP
or
.PP
.Vb 1
\&    frame[\-4:] == 0.1.2.3
.Ve
.PP
A slice is always compared against either a string or a byte sequence.
As a special case, when the slice is only 1 byte wide, you can compare
it against a hex integer that 0xff or less (which means it fits inside
one byte). This is not allowed for byte sequences greater than one byte,
because then one would need to specify the endianness of the multi-byte
integer. Also, this is not allowed for decimal numbers, since they
would be confused with hex numbers that are already allowed as
byte strings. Neverthelss, single-byte hex integers can be convienent:
.PP
.Vb 1
\&    frame[4] == 0xff
.Ve
.PP
Slices can be combined. You can concatenate them using the comma operator:
.PP
.Vb 1
\&    ftp[1,3\-5,9:] == 01:03:04:05:09:0a:0b
.Ve
.PP
This concatenates offset 1, offsets 3\-5, and offset 9 to the end of the ftp
data.
.SS "The membership operator"
.IX Subsection "The membership operator"
A field may be checked for matches against a set of values simply with the
membership operator. For instance, you may find traffic on common HTTP/HTTPS
ports with the following filter:
.PP
.Vb 1
\&    tcp.port in {80 443 8080}
.Ve
.PP
as opposed to the more verbose:
.PP
.Vb 1
\&    tcp.port == 80 or tcp.port == 443 or tcp.port == 8080
.Ve
.PP
To find HTTP requests using the HEAD or GET methods:
.PP
.Vb 1
\&    http.request.method in {"HEAD" "GET"}
.Ve
.PP
The set of values can also contain ranges:
.PP
.Vb 3
\&    tcp.port in {443 4430..4434}
\&    ip.addr in {10.0.0.5 .. 10.0.0.9 192.168.1.1..192.168.1.9}
\&    frame.time_delta in {10 .. 10.5}
.Ve
.SS "Type conversions"
.IX Subsection "Type conversions"
If a field is a text string or a byte array, it can be expressed in whichever
way is most convenient.
.PP
So, for instance, the following filters are equivalent:
.PP
.Vb 2
\&    http.request.method == "GET"
\&    http.request.method == 47.45.54
.Ve
.PP
A range can also be expressed in either way:
.PP
.Vb 2
\&    frame[60:2] gt 50.51
\&    frame[60:2] gt "PQ"
.Ve
.SS "Bit field operations"
.IX Subsection "Bit field operations"
It is also possible to define tests with bit field operations. Currently the
following bit field operation is supported:
.PP
.Vb 1
\&    bitwise_and, &      Bitwise AND
.Ve
.PP
The bitwise AND operation allows testing to see if one or more bits are set.
Bitwise AND operates on integer protocol fields and slices.
.PP
When testing for TCP SYN packets, you can write:
.PP
.Vb 1
\&    tcp.flags & 0x02
.Ve
.PP
That expression will match all packets that contain a "tcp.flags" field
with the 0x02 bit, i.e. the SYN bit, set.
.PP
Similarly, filtering for all WSP GET and extended GET methods is achieved with:
.PP
.Vb 1
\&    wsp.pdu_type & 0x40
.Ve
.PP
When using slices, the bit mask must be specified as a byte string, and it must
have the same number of bytes as the slice itself, as in:
.PP
.Vb 1
\&    ip[42:2] & 40:ff
.Ve
.SS "Logical expressions"
.IX Subsection "Logical expressions"
Tests can be combined using logical expressions.
These too are expressible in C\-like syntax or with English-like
abbreviations:
.PP
.Vb 3
\&    and, &&   Logical AND
\&    or,  ||   Logical OR
\&    not, !    Logical NOT
.Ve
.PP
Expressions can be grouped by parentheses as well.  The following are
all valid display filter expressions:
.PP
.Vb 4
\&    tcp.port == 80 and ip.src == 192.168.2.1
\&    not llc
\&    http and frame[100\-199] contains "wireshark"
\&    (ipx.src.net == 0xbad && ipx.src.node == 0.0.0.0.0.1) || ip
.Ve
.PP
Remember that whenever a protocol or field name occurs in an expression, the
"exists" operator is implicitly called. The "exists" operator has the highest
priority. This means that the first filter expression must be read as "show me
the packets for which tcp.port exists and equals 80, and ip.src exists and
equals 192.168.2.1". The second filter expression means "show me the packets
where not (llc exists)", or in other words "where llc does not exist" and hence
will match all packets that do not contain the llc protocol.
The third filter expression includes the constraint that offset 199 in the
frame exists, in other words the length of the frame is at least 200.
.PP
A special caveat must be given regarding fields that occur more than
once per packet.  "ip.addr" occurs twice per IP packet, once for the
source address, and once for the destination address.  Likewise,
"tr.rif.ring" fields can occur more than once per packet.  The following
two expressions are not equivalent:
.PP
.Vb 2
\&        ip.addr ne 192.168.4.1
\&    not ip.addr eq 192.168.4.1
.Ve
.PP
The first filter says "show me packets where an ip.addr exists that
does not equal 192.168.4.1".  That is, as long as one ip.addr in the
packet does not equal 192.168.4.1, the packet passes the display
filter.  The other ip.addr could equal 192.168.4.1 and the packet would
still be displayed.
The second filter says "don't show me any packets that have an
ip.addr field equal to 192.168.4.1".  If one ip.addr is 192.168.4.1,
the packet does not pass.  If \fBneither\fR ip.addr field is 192.168.4.1,
then the packet is displayed.
.PP
It is easy to think of the 'ne' and 'eq' operators as having an implicit
"exists" modifier when dealing with multiply-recurring fields.  "ip.addr
ne 192.168.4.1" can be thought of as "there exists an ip.addr that does
not equal 192.168.4.1".  "not ip.addr eq 192.168.4.1" can be thought of as
"there does not exist an ip.addr equal to 192.168.4.1".
.PP
Be careful with multiply-recurring fields; they can be confusing.
.PP
Care must also be taken when using the display filter to remove noise
from the packet trace. If, for example, you want to filter out all IP
multicast packets to address 224.1.2.3, then using:
.PP
.Vb 1
\&    ip.dst ne 224.1.2.3
.Ve
.PP
may be too restrictive. Filtering with "ip.dst" selects only those
\&\fBIP\fR packets that satisfy the rule. Any other packets, including all
non-IP packets, will not be displayed. To display the non-IP
packets as well, you can use one of the following two expressions:
.PP
.Vb 2
\&    not ip or ip.dst ne 224.1.2.3
\&    not ip.addr eq 224.1.2.3
.Ve
.PP
The first filter uses "not ip" to include all non-IP packets and then
lets "ip.dst ne 224.1.2.3" filter out the unwanted IP packets. The
second filter has already been explained above where filtering with
multiply occurring fields was discussed.
.SH "FILTER FIELD REFERENCE"
.IX Header "FILTER FIELD REFERENCE"
The entire list of display filters is too large to list here. You can
can find references and examples at the following locations:
.IP \(bu 4
The online Display Filter Reference: <https://www.wireshark.org/docs/dfref/>
.IP \(bu 4
\&\fIHelp:Supported Protocols\fR in Wireshark
.IP \(bu 4
\&\f(CW\*(C`tshark \-G fields\*(C'\fR on the command line
.IP \(bu 4
The Wireshark wiki: <https://wiki.wireshark.org/DisplayFilters>
.SH NOTES
.IX Header "NOTES"
The \fBwireshark-filters\fR manpage is part of the \fBWireshark\fR distribution.
The latest version of \fBWireshark\fR can be found at
<https://www.wireshark.org>.
.PP
Regular expressions in the "matches" operator are provided by GRegex in GLib.
See <http://developer.gnome.org/glib/2.32/glib\-regex\-syntax.html> or <http://www.pcre.org/> for more information.
.PP
This manpage does not describe the capture filter syntax, which is
different. See the manual page of \fBpcap\-filter\fR\|(7) or, if that doesn't exist,
\&\fBtcpdump\fR\|(8), or, if that doesn't exist, <https://wiki.wireshark.org/CaptureFilters>
for a description of capture filters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBwireshark\fR\|(1), \fBtshark\fR\|(1), \fBeditcap\fR\|(1), \fBpcap\fR\|(3), \fBpcap\-filter\fR\|(7) or \fBtcpdump\fR\|(8) if it
doesn't exist.
.SH AUTHORS
.IX Header "AUTHORS"
See the list of authors in the \fBWireshark\fR man page for a list of authors of
that code.
